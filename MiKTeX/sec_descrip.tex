\section{Обзор литературы}
\label{sec:descript}

Целью литературного обзора является исключение неоправданного дублирования исследований и разработок, глубокое изучение и широкое использование последних достижений науки и техники в отрасли, обеспечение конкурентоспособности и высокого технического уровня объектов разработки.
Выбор пути оптимального решения задачи предполагает отбор лучших разработок, которые могут быть использованы в качестве прото­типа или в виде модуля в собственной разработке.

Проведению литературно обзора предшествует просмотр научно\\-технической и популярной литературы, анализ проектов с открытым исходным кодом в популярных системах контроля версий.

Основной задачей литературно обзора является выяснение того, как решаются аналогичные задачи другими разработчиками, а также в каком направлении следует проводить исследования в данной области разработки.

С учётом темы дипломного проекта, организация поиска проводилась по тематике достижений в области криптографических систем и других систем хранения и защиты пользовательских данных.

\subsection{Обзор существующих программ} % (fold)
\label{sub:descript:existing_programs}

Существует множество менеджеров паролей с шифрованием/дешифрованием данных, но лишь не многие из них представляют веб-интерфейс для удобной работы в сети.
Ниже приведены некоторые из задач, которые может выполнять типичный менеджер паролей:
\begin{itemize}
  \item ручное, автоматическое, полу"=автоматическое создание сертификатов доступа к хранилищу;
  \item оценку параметров условных распределений записей по представленным данным;
  \item реализацию статистического вывода суждений о безопастности хранения предоставленных данных;
  \item работу с группами записей и группами хранилищ;
  \item предоставление доступа к шифрованным данным и безопасное хранение, предоставленной пользователем, информации;
  \item предоставление доступа к функционалу приложения посредством веб-интерфейса.
\end{itemize}

Приняв во внимание тему дипломного проекта, наибольший интерес в существуем программном обеспечении будет представлять функциональность предоставление доступа к шифрованным данным и их безопасное хранение.
Ниже рассматриваются некоторые из программ реализующие решение описанных выше задач.

\subsubsection{}
\label{sub:descript:existing_programs:lastpass}

LastPass\footnote{\url{https://lastpass.com/}} довольно старый менеджер паролей. Весь его функционал по управлению паролями реализован через веб-приложение и через браузерные плагины.
База данных с паролями шифруется с помощью AES-256 и синхронизируется между хранилищем плагина и сервером LastPass. Есть также portable-версии, причем как браузерных плагинов, так и самостоятельного приложения под Windows.
Также стоит отметить, что мобильные приложения есть для любой мобильной платформы. Более того, например, для Android есть как отдельное приложение, так и плагин для браузера Dolphin~\cite{dolphin}.
Версия программы с ограниченной функциональностью свободно доступна на сайте LastPass.

\subsubsection{}
\label{sub:descript:existing_programs:myonelogin}

My1login\footnote{\url{https://www.my1login.com/}} позволяет распространять записи хранилища по общедоступным API. В основе лежит веб-приложение, с возможностью редактировать записи, а для сохранения их из форм и автоматического ввода существует \javascr{} букмарклет. Основной возможностей менеджера паролей является групповая работа с записями хранилища.
Подобный функционал будет полезен группам, которые имеют внутри себя определенную базу реквизитов. В данном случае, после плановой смены пароля к определенному сервису отпадет необходимость в сообщении новых данных каждому пользователю.
Обладает уникальной моделью двухступенчатой авторизации.
В отличии от Lastpass, описанного в подразделе~\ref{sub:descript:existing_programs:lastpass}, не предоставляет доступ к удаленному хранилищу, что затруднет его использование на различных платформах.

\subsubsection{}
\label{sub:descript:existing_programs:myonelogin}

Bluepass\footnote{\url{https://bluepass.org/}} является менеджером паролей с открытым исходным кодом.
Он реализован на Python, что позволило разработчикам создать кроссплатформенное приложение для десктопных клиентов. Обеспечивает синхронизацию по протоколу P2P, тем самым снижая вероятность массовой утечки реквизитов. На текущий момент не имеет веб-интерфейс для работы в сети.

\subsection{Оценка стойкости шифра в системах с открытым ключом} % (fold)
\label{sub:descript:crypto}

Стойкость систем с открытым ключом основывается на большой вычислительной сложности известных алгоритмов разложения числа на простые сомножители. Выражение для разложения числа согласно основной теореме арифметики в общем случае представлено формулой~(\ref{eq:descript:crypto:model_length}):
\begin{align}
  \label{eq:descript:crypto:model_length}
  \Phi \left ( n \right ) &=
  \Phi \left ( p_{1}^{q1} \right )
  \cdot \Phi \left ( p_{2}^{q2} \right )
  \cdots \Phi \left ( p_{k}^{qk} \right ) =\notag\\
   &= p_{1}^{q1}
  \cdot \left ( 1-\frac{1}{p_{1}} \right )
  \cdot p_{2}^{q2}\left ( 1-\frac{1}{p_{2}} \right )
  \cdots p_{k}^{qk}\left ( 1-\frac{1}{p_{k}} \right )
   \text{\,,}
\end{align}
\begin{explanation}
где & $ \Phi $ & функция Эйлера "---  мультипликативная арифметическая функция, равная количеству натуральных чисел; \\
    & $ p_{k} $ и $ q $ & простые числа.
\end{explanation}

Следует отметить, что $ p $ и $ q $ выбираются таким образом, чтобы $ n $ было больше кода любого символа открытого сообщения. В автоматизированных системах исходное сообщение переводиться в двоичное представление, после чего шифрование выполняется над блоками бит равной длины. При этом длина блока должна быть меньше, чем длина двоичного представления $ n $.

Несмотря на то, что доказательство гипотезы~\cite[с.~26\,--\,30]{euler_cornell}, которая лежит в основе функции Эйлера в криптографических системах, о том, что нет такого значения m, которое функция Эйлера принимала бы только один раз, содержит ошибку $ \dim(\varphi^{-1}(m)) = 1, то n > 10^{37} $, ее продолжают использовать в различных современных сетевых системах, требующих минимальное количество затрат ресурсов.

Для решения ошибки факторизации функции Эйлера во многих системах используется простой алгоритм перебора делителей~\cite{algo_differ}, путем полного перебора всех возможных потенциальных делителей. Суть алгоритма заключается в переборе всех целых чисел $ i $ от двух до $ \sqrt{n} $ и вычислении остатка от деления $ n \mod i $. Если остаток от деления равен нулю, то $i$ является делителем $n$. В случае, если $i > \sqrt{n}$, то $n$ является простым сомножителем.

Для осуществления поиска всех простых делителей числа $n$ необходимо использовать описанный выше алгоритм рекурсивно, для каждого вновь найденного делителя.

В связи с этим, в рамках системы с асинхронным шифрованием, был разработана реализация алгоритма К2, приведенный в работе~\cite{Cooper1991}, псевдокод которого показан в листинге~\ref{lst:arch_and_mod:k2_algorithm:k2_pseudo}.
Он использует вероятностные сети, как одним из возможных способов представления совместного распределения множества простых чисел.
Здесь и далее под назначением простых чисел $ X_1, X_2,\\ \dotsc, X_n $ понимаются определенные значения, которые принимают случайные величины.
Табличное представление совместного распределения растет экспоненциально количеству переменных и состояний, которые эти переменные могут принимать.
Благодаря информации о независимости, распределение $ P(X_1, X_2,\dotsc, X_n) $ может быть факторизовано более просто, чем с использованием функции Эйлера $ P(X_1, X_2,\dotsc, X_n) = P(X_1) P(X_2|X_1) \dotsm P(X_n|X_1,\times \times,X_{n-1}) $.
При наличии информации о данных, подвергаемым кодировке, совместное распределение случайных величин может быть факторизовано по формуле:
\begin{equation}
  \label{eq:domain:bayes_net:joint_disitr}
  P(X_1, X_2,\dotsc, X_n) = \prod_{i = 0}^{n}{P(X_i|X_{\pi_i})} \text{\,,}
\end{equation}
\begin{explanation}
где & $ \pi_i $ & множество индексов переменных"=родителей для переменной $X_i$.
\end{explanation}

Данное представление совместного распределения все так же имеет экспоненциальный рост количества стохастических параметров от количества переменных и их состояний.
Но на практике, обычно они имеют небольшую связанность, далекую от $ \dim(\varphi^{-1}(m)) = 1, то n > 10^{37} $, что позволяет представлять простые числа в сетевых системах криптографии.

Необходимо отметить, что существует пример успешного коммерческого применения одной из модификаций подобного подхода. К сожалению, работы, в которых данные сети были бы формализованы и математически доказана их корректность, пока не публиковались в открытых источниках.
Отличие данной модификации от классических сети заключается в том, что таблицы условных распределений $ P(X_k | X_{\pi_k}) $, где $k$ "--- индекс случайной величины, ассоциированные с вершинами графа и имеющими размерность разрядности искомого простого числа $ \alpha_k \cdot \prod_{j \in \pi_k}\alpha_j $, заменяются на $ n $ таблиц меньшего размера, представляющих условные распределения $ P(X_k | X_j) $, где $ j \in \pi_k,\ k = 1,\dotsc,n $, ассоциированных с дугами графа и имеющими общую размерность $ \alpha_k \cdot \sum_{j \in \pi_k}\alpha_j $, где $\alpha_j$~--- количество значений, которые может принимать случайная величина $X_j$.

Разработанная в рамках дипломного проекта реализация сети предназначена для работы именно с таким алгоритмом. Он позволяет в в рамках запроса пользователя определить стойкость системы, на основании переданных данных, решая проблему факторизации, существующую для данных систем.


