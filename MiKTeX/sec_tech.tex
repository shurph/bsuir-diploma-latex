\section{Программа и методика тестирования программного продукта}
\label{sec:practice:technology_used}

Очень часто современные программные продукты разрабатываются в сжатые сроки и при ограниченных бюджетах проектов. Программирование сегодня перешло из разряда искусства, став при этом ремеслом для многих миллионов специалистов. Но, к сожалению, в такой спешке разработчики зачастую игнорирует необходимость обеспечения информационной безопасности и защищённости своих продуктов, подвергая тем самым пользователей своих продуктов неоправданному риску.

Тестированием называют процесс выполнения программы с различными исходными данными, для которых заранее известны результаты. Интуитивно начинающие программисты обычно целью тестирования считают проверку правильности программы, что совершенно не верно. В большинстве случаев перебрать все возможные комбинации данных невозможно, а выборочное тестирование не доказывает правильности программы, так как-то, что программа работает на десяти наборах данных, не означает, что она будет давать правильные результаты на одиннадцатом наборе. Поэтому, целью тестирования является обнаружение ошибок.

Существующие на сегодня методы тестирования программного обеспечения не позволяют однозначно и полностью выявить все дефекты и установить корректность функционирования анализируемой программы, поэтому все существующие методы тестирования действуют в рамках формального процесса проверки исследуемого или разрабатываемого программного обеспечения.
Такой процесс формальной проверки, или верификации, может доказать, что дефекты отсутствуют с точки зрения используемого метода.

Существует множество подходов к решению задачи тестирования и верификации программного обеспечения, но эффективное тестирование сложных программных продуктов — это процесс в высшей степени творческий, не сводящийся к следованию строгим и чётким процедурам или созданию таковых.

Ниже описаны причины, почему испытание программного обеспечения является обязательным моментом при разработке.

Подобная проверка помогает удостовериться, что у выпускаемого программного обеспечения нет каких-либо технических недоработок. Если же они всё-таки есть, то её разработчики смогут узнать об этом до выпуска программного обеспечения в широкое производство и исправить их. Таким образом, можно будет гарантировать, что программное обеспечение будет работать должным образом.
Если программное обеспечение не проходит проверку и выпускается на рынок, то возникает вероятность его неправильной работы. Это может привести к печальным последствиям особенно, если его используют в организациях для работы с важными операциями. А это в свою очередь приведет к тому, что разработчики этого программного обеспечения понесут дополнительные убытки, поскольку именно они ответственны за неправильную работу своих программ.

Дипломный проект тестировался на машинах со следующей конфигурацией:
\begin{enumerate}
  \item Intel Core~i7, оперативная память 16~ГБ, видеокарта GeForce 9600 MGT~256~МБ. Операционная система Windows~7 Ultimate x32 Service Pack~1.
  \item AMD Phenom~2 ядра по 3,0~ГГц, оперативная память 8~ГБ, видеокарта Ge~Force 760~GTX~512Mb. Операционная система Windows 7 Ultimate~x64.
\end{enumerate}

Тестирование производилось на сервере, в среде максимально близкой к реальному режиму работы финальной версии приложения. Тестирование осуществлялось специально обученным человеком по составленным заранее тест кейсам.

\subsection{Ручное тестирование}
\label{sec:practice:technology_used:hand_test}

Каждому новому этапу разработки программного продукта, в рамка темы дипломного проекта, предшествовал процесс ручного тестирования. Он производился без использования программных средств,  путем моделирования действий пользователя. В роли тестировщиков также выступали и обычные пользователи, сообщая разработчикам о найденных ошибках.

Тестирование проводилось как модульно, так и в полном цикле работы приложения.
Отдельно тестировались модули регистрации, авторизации, создания нового хранилища пользователем, подтверждения открытого ключа. Также особое внимание уделялось тестированию различных типов проектов производителя. Отдельно тестировалась система загрузки отчетов и логов.

Полный цикл тестирования включал в себя:
\begin{itemize}
  \item добавление новых записей в хранилище;
  \item наполнение записей в каждой группе;
  \item проверку всех полей ввода на максимально допустимые и граничные значения;
  \item проверка правильного выполнения бизнес логики приложения;
  \item проверка интеграции со средой работы пользователя.
\end{itemize}

\subsection{Unit-тестирование}
\label{sec:practice:technology_used:unit}

В качестве проверки на соответствие разрабатываемой системы и заложенного функционала были написаны unit-тесты. Покрытие исходного кода приложения unit-тестами заметно сократило количество потенциальных ошибок, однако это потребовало дополнительного времени.

Полное покрытие модулей unit-тестами позволило достаточно быстро проверять, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчило обнаружение и их устранение.

Поскольку некоторые классы могут использовать другие классы, тестирование отдельного класса часто распространяется на связанные с ним. Например, класс пользуется базой данных. Это ошибка, решение которой сводиться к введению абстракции соединения с базой данных и реализации ее интерфейса, посредством собственного mock-объекта. Это приводит к менее связанному коду, минимизируя зависимости в системе.

При выполнении unit-тестов происходит тестирование каждого из модулей по отдельности. Это означает, что ошибки интеграции, системного уровня, функций, исполняемых в нескольких модулях, не будут определены. Кроме того, данная технология бесполезна для проведения тестов на производительность. Таким образом, модульное тестирование более эффективно при использовании в сочетании с другими методиками тестирования.

Unit-тестами покрывались наиболее критические участки работы приложения такие как:
\begin{itemize}
  \item создание и редактирование записей;
  \item функционирование различных типов компонент;
  \item добавление/удаление записей;
  \item совместимость пар генерируемых ключей;
  \item встановление и нормализацию данных пользователя.
\end{itemize}