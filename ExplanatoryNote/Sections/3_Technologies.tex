\section{Используемые технологии}

Выбор технологий является важным предварительным этапом разработки сложных информационных систем.
Платформа и язык программирования, на котором будет реализована система, заслуживает большого внимания, так как исследования показали, что выбор языка программирования влияет на производительность труда программистов и качество создаваемого ими кода \cite{CodeComplete}.

Выбор игрового движка является важных предварительным этапом в разработке компьютерных игр. Для того, чтобы сузить список вариантов формируют список первоначальных факторов, влияющих на выбор:
\begin{itemize}
    \item разрабатываемый ПП должен работать на операционных системах Android и iOS;
    \item среди различных платформ разработки имеющийся программист лучше всего знаком с разработкой на платформе \DotNet;
    \item игровой движок должен поддерживать как 2D графику, так и 3D;
    \item для игрового движка должно существовать достаточное количество библиотек для реализации таких возможностей, как: внутриигровые покупки, отображение рекламы, система UI.
\end{itemize}

Исходя из выбранных факторов были выделены несколько фаворитов:

\textbf{Unity} -- один из популярнейших игровых движков. Главных направлением развития этого движка является простота и скорость разработки, что и обеспечило ему такую популярность \cite{Unity}.

Преимущества Unity:
\begin{itemize}
    \item код пишется на языке программирования \CSharp;
    \item движок ориентирован на разработку игр различных жанров;
    \item в основе иерархии игровых объектов стоит компонентно-ориенти\-рованное программирование \cite{COP};
    \item обширное сообщество пользователей и большой магазин компонентов -- Asset Store, продающий элементы для игр: модели, текстуры, скрипты, редакторы, инструменты, серверные подсистемы и т.п. Все это создают пользователи движка -- участники сообщества.
\end{itemize}

Недостатки Unity:
\begin{itemize}
    \item Unity является программным продуктом с закрытым исходным кодом, лишь некоторые компоненты движка (такие как например система UI или мультиплеер) имеют открытый исходный код;
    \item в связи с тем, что движок ориентирован на простоту разработки и на разработку игр различных жанров, то порой бывает сложно поменять заранее установленное разработчиками движка поведение.
\end{itemize}

\textbf{Unreal Engine} -- один из наиболее популярных движков для разработки ААА-игр \cite{Unreal}.

Преимущества Unreal Engine:
\begin{itemize}
    \item движок поставляется вместе со всем исходным кодом;
    \item наличие продвинутых механизмов рендеринга, обеспечивающие высокий уровень графики;
    \item чертежи (blueprints) удобны для того, чтобы быстро создать что-нибудь простое и реализовать базовую игровую логику.
\end{itemize}

Недостатки Unreal Engine:
\begin{itemize}
    \item при разработке на Unreal Engine сложно набрать темп. Даже если вы отлично знаете \CPP, потребуется немало времени для изучения различных макросов и функций Unreal Engine. Это может быть очень сложно для тех, кто одновременно занимается изучением \CPP;
    \item мобильная разработка с Unreal Engine медленная. Программа развертывается на устройстве очень долго. Unreal Engine поддерживает сборку для устройства с iOS лишь при условии, что ваше приложение состоит только из чертежей;
    \item изначально движок проектировался для создания игр в жанре FPS\footnote{First Person Shooter -- жанр видеоигр, в котором игровой процесс основывается на сражениях с использованием огнестрельного и метательного оружия с видом от первого лица}, что создаёт некоторые неудобства при создании игр других жанров;
\end{itemize}

Из двух представленных игровых движков был выбран Unity по ряду следующих причин:
\begin{itemize}
    \item разработка на \CSharp по сравнению \CPP является более предпочтительной;
    \item т.к. разработка ведётся под мобильные платформы, то наличие высокого уровня графики не является необходимым условием;
    \item разрабатываемая игра принадлежит к типу казуальных игр, который лучше поддерживается игровым движком Unity.
\end{itemize}

Далее проводится характеристика используемых технологий и языков программирования более
подробно.


\subsection{Unity}

Unity -- кроссплатформенный игровой движок для разработки двухмерных и трехмерных приложений и игр под различные платформы. У Unity есть две версии: бесплатная и платная. Отличаются они рядом возможностей, которые могут сильно понадобиться при разработке игры. Во-первых, бесплатная версия Unity поддерживает только Android, Web Player, PC-платформы. Полная версия позволяет разработчикам выкладывать своё творение под все самые известные платформы, такие как: PC, Linux, Mac, Windows Store, IOS, Android, Windows Phone 10 Store, Blackberry 10, Wii U, PS3, Xbox 360, PS4, Xbox One. Есть возможность делать софт для VR\footnote{Virtual Reality}, т.е. под очки и шлемы виртуальной реальности: Hololens, Oculus Rift, StarVR и прочие, а также писать программы для Kinect 2.0, LeapMotion. Полную версию Unity можно адаптировать под свои нужды: например, если вас интересует разработка софта под Kinect 2.0, вы можете убрать некоторые элементы меню в интерфейсе и дополнить его своими надстройками, которые реально облегчат разработку.

Unity имеет очень простой Drag and Drop интерфейс, который человек осваивает за месяц. Весь движок (от и до) только на английском языке. Русификации Unity нет. Unity разбит на несколько окон: Hierarchy, где находятся названия всех объектов на сцене, которые можно группировать и легко переходить по ним, Scene, где можно рассмотреть определенную сцену под нужным вам ракурсом, Inspector, который поможет с настройкой выделенного объекта, Project, где видны все материалы проекта, Toolbar\footnote{меню с инструментами}.

Unity поддерживает два языка: \CSharp (наиболее используемый) и Java \linebreak Script. Разработчику необходимо знать один из языков в совершенстве, а другой на среднем уровне, так как некоторые моменты Unity делает только на одном из двух языков, или это делается намного труднее, чем на другом языке программирования. Unity 4, поддерживала язык программирования Boo (диалект Phyton), но его убрали из 5-ой версии, так как им практически никто не пользовался, да и документации, если честно, на официальном сайте Unity особо не было. Расчеты физики в Unity производит та же NVIDIA PhysX, которая, кстати, отлично с этим справляется. Совсем недавно NVIDIA представила одну интересную вещь -- NVIDIA Flex, которую, возможно, в будущем встроят в игровые движки.

Объекты в Unity могут быть пустыми, (чтобы объединить несколько объектов в одну группу, т.е. сделать их дочерними GameObject), содержать компоненты, с которыми взаимодействуют скрипты, могут быть названы одним и тем же именем, могут быть присвоены теги, которые служат для того, чтобы скрипт нашел нужный нам объект. К объектам в Unity можно присвоить коллайдеры: Box Collider -- куб, в который попадает модель объекта, Sphere Collider -- сфера, Character Collider -- коллайдер, который был специально введен в Unity для использования под персонажей, Mesh Collider -- коллайдер, созданный по мешу, то есть повторяющий геометрию объекта, Wheel Collider -- коллайдер для колес, Terrain Collider -- коллайдер для Terrain -- площадки, которую используют для отображения земли.

Анимировать модели в Unity можно несколькими способами: создание анимаций в специальных программах, например: 3Ds Max, Blender и прочие, а можно и в самом Unity, так как редактор Unity имеет компонент для их создания. Материалы в Unity играют важную роль. Импортированные текстуры в Unity прикрепить к объекту нельзя, необходимо создать материал, который можно присваивать игровому объекту. К назначенным материалу шейдерам будут присвоены текстуры. Шейдеры можно редактировать прямо в Unity. Unity позволяет
генерировать нормал-мапы (normal-map), лайт-мапы (light-map), различные альфа-каналы и mip-уровни.

Unity имеет две очень важные особенности: Occlusion Culling и Level Of Detail. Обе вещи позволяют сильно снизить нагрузку на центральный процессор, благодаря грамотной детализации. Например, в играх жанра 2D и 3D Runner при преодолении определенной дистанции все, что было позади вас, удаляется, а то, что впереди вас, генерируется. Таким образом, при длительной игре ваше устройство не захламляет ненужная информация. Occlusion Culling не визуализирует геометрию и коллайдеры объектов, находящихся не в поле зрении камеры, а Level Of Detail заменяет детализированные объекты, находящиеся далеко от игрока, на менее детализированные, причем разработчик сам настраивает эту систему. То есть скромный проект может позволить выставить огромные значения в Level of Detail, когда AAA-проекты выставляют его на минимум.

Unity обладает огромным количеством преимуществ перед другими игровыми движками. Коммьюнити Unity на сегодняшний момент является самым большим в мире. На официальном сайте Unity есть специальный раздел, в котором можно найти статистику по игровым движкам. По этим данным Unity используют более 50\% разработчиков видеоигр. 20\% принадлежат Unreal Engine, а остальные игровые движки -- 30\%. Для разработки 2D или 3D инди-игр Unity подходит по всем параметрам. В Unity очень просто компилировать проекты. Причем можно создать один проект под множество платформ, что очень сильно облегчает процесс для разработчиков.


\subsection{\DotNet и Mono}

Программная платформа \DotNet является одной из реализаций стандарта ECMA-335 \cite{ECMA335} и является современным инструментом создания клиентских и серверных приложений для операционной системы Windows. Первая общедоступная версия \DotNet вышла в феврале 2002 года. С тех пор платформа активно эволюционировала и на данный момент было выпущено шесть версии данного продукта. На данный момент номер последней версии \DotNet -- 4.5. Платформа \DotNet была призвана решить некоторые наболевшие проблемы, скопившиеся на момент её выхода, в средствах разработки приложений под Windows. Ниже перечислены некоторые из них \cite{Richter}:
\begin{itemize}
    \item сложность создания надежных приложений;
    \item сложность развертывания и управления версиями приложений и библиотек;
    \item сложность создания переносимого ПО;
    \item отсутствие единой целевой платформы для создателей компиляторов;
    \item проблемы с безопасным исполнением непроверенного кода;
    \item великое множество различных технологий и языков программирования, которые не совместимы между собой.
\end{itemize}

Многие из этих проблем были решены. Далее более подробно рассматривается внутреннее устройство \DotNet.

Основными составляющими компонентами \DotNet являются общая языковая исполняющая среда CLR\footnote{Common Language Runtime} и стандартная библиотека классов FCL\footnote{Framework Class Library}. CLR представляет из себя виртуальную машину и набор сервисов обслуживающих исполнение программ, написанных для \DotNet. Ниже приводится перечень задач, возлагаемых на CLR \cite{Marchenko}:
\begin{itemize}
    \item загрузка и исполнение управляемого кода;
    \item управление памятью при размещении объектов;
    \item изоляция памяти приложений;
    \item проверка безопасности кода;
    \item преобразование промежуточного языка в машинный код;
    \item доступ к расширенной информации о типах -- метаданным;
    \item обработка исключений, включая межъязыковые исключения;
    \item взаимодействие между управляемым и неуправляемым кодом (в том числе и COM-объектами);
    \item поддержка сервисов для разработки (профилирование, отладка и т.\,д.).
\end{itemize}

Программы, написанные для \DotNet представляют из себя набор типов, взаимодействующих между собой. \DotNet имеет общую систему типов CTS\footnote{Common Type System}. Данная спецификация описывает определения и поведение типов, создаваемых для \DotNet \cite{Richter}. В частности, в данной спецификации описаны возможные члены типов, механизмы сокрытия реализации, правила наследования, типы-значения и ссылочные типы, особенности параметрического полиморфизма и другие возможности, предоставляемые CLI. Общая языковая спецификация CLS\footnote{Common Language Specification} -- подмножество общей системы типов. Это набор конструкций и ограничений, которые являются руководством для создателей библиотек и компиляторов в среде \DotNet. Библиотеки, построенные в соответствии с CLS, могут быть использованы из любого языка программирования, поддерживающего CLS. Языки, соответствующие CLS (к их числу относятся языки \CSharp, Visual Basic .NET, Visual C++/CLI), могут интегрироваться друг с другом. CLS -- это основа межъязыкового взаимодействия в рамках платформы \DotNet \cite{Marchenko}.

Некоторые из возможностей, предоставляемых \DotNet: верификация кода, расширенная информация о типах во время исполнения, сборка мусора, безопасность типов, -- невозможны без наличия подробных метаданных о типах из которых состоит исполняемая программа. Подробные метаданные о типах генерируются компиляторами и сохраняются в результирующих сборках. Сборка -- это логическая группировка одного или нескольких управляемых модулей или файлов ресурсов, является минимальной единицей с точки зрения повторного использования, безопасности и управлениями версиями \cite{Richter}.

Одной из особенностей \DotNet, обеспечивающей переносимость программ без необходимости повторной компиляции, является представление исполняемого кода приложений на общем промежуточном языке CIL\footnote{Common Intermediate Language}. Промежуточный язык является бестиповым, стековым, объекто-ориентированным ассемблером \cite{Richter}. Данный язык очень удобен в качестве целевого языка для создателей компиляторов и средств автоматической проверки кода для платформы \DotNet, также язык довольно удобен для чтения людьми. Наличие промежуточного языка и необходимость создания производительных программ подразумевают наличие преобразования промежуточного кода в машинный код во время исполнения программы. Одним из компонентов общей языковой исполняющей среды, выполняющим данное преобразование, является компилятор времени исполнения JIT\footnote{Just-In-Time compiler} транслирующий промежуточный язык в машинные инструкции, специфические для архитектуры компьютера на котором исполняется программа.

Ручное управление памятью всегда являлось очень кропотливой и подверженной ошибкам работой. Ошибки в управлении памятью являются одними из наиболее сложных в устранении типами программных ошибок, также эти ошибки обычно приводят к непредсказуемому поведению программы, поэтому в \DotNet управление памятью происходит автоматически \cite{Richter}. Автоматическое управление памятью является механизмом поддержания иллюзии бесконечности памяти. Когда объект данных перестает быть нужным, занятая под него память автоматически освобождается и используется для построения новых объектов данных. Имеются различные методы реализации такого автоматического распределения памяти \cite{SICP}. В \DotNet для автоматического управления памятью используется механизм сборки мусора (garbage collection). Существуют различные алгоритмы сборки мусора со своими достоинствами и недостатками. В \DotNet используется алгоритм пометок (mark and sweep) в сочетании с различными оптимизациями, такими как, например, разбиение всех объектов по поколениям и использование различных куч для больших и малых объектов.

Ниже перечислены, без приведения подробностей, некоторые важные функции исполняемые общей языковой исполняющей средой:
\begin{itemize}
    \item обеспечение многопоточного исполнения программы;
    \item поддержание модели памяти, принятой в CLR;
    \item поддержка двоичной сериализации;
    \item управление вводом и выводом;
    \item структурная обработка исключений;
    \item возможность размещения исполняющей среды внутри других процессов.
\end{itemize}

Как уже упоминалось выше, большую ценностью для \DotNet представляет библиотека стандартных классов -- объектно-ориентиро\-ванная библиотека классов, интерфейсов и системы типов (типов-значений), которые включаются в состав платформы \DotNet. Эта библиотека обеспечивает доступ к функциональным возможностям системы и предназначена служить основой при разработке .NET-приложений, компонент, элементов управления \cite{Marchenko}.

Mono -- программная платформа, позволяющая разработчикам достаточно просто создавать развитые кроссплатформенные приложения. Технология Mono разрабатывается в виде open source реализации технологии \DotNet от Microsoft и поддерживает стандарты ECMA-334 (стандарт языка \CSharp) и ECMA-335 \cite{ECMA335}. Открытость указанных стандартов позволяет уменьшить проблемы создания кроссплатформенных приложений.

В базовом варианте Mono состоит из нескольких компонентов:
\begin{itemize}
    \item Компилятор языка \CSharp -- компилятор с полной поддержкой версий 1.0 и 2.0 языка \CSharp. Кроме того, в последних версиях поддерживаются практически все возможности версии \CSharp 3.0, а начиная с версии Mono 2.6 включена поддержка возможностей версии \CSharp 4.0;
    \item Среда исполнения Mono -- состоит из среды исполнения CLI непосредственно, компилятора среды исполнения JIT, генератора машинного кода AOT\footnote{Ahead-Of-Time}, загрузчика сборок, сборщика мусора, подсистемы управления многопоточностью и компонентов поддержки взаимодействия между сборками и COM (или аналогами в Linux, например, XCOM);
    \item Базовая библиотека классов -- набор стандартных классов, совместимых с классами Microsoft \DotNet;
    \item Библиотека классов Mono -- набор классов, поддерживающих дополнительные функции для разработки Linux-приложений. Например, классы для поддержки Zip, OpenGL, Cairo, Gtk+.
\end{itemize}


\subsection{Язык программирования \CSharp}

Главной особенностью языка \CSharp является его ориентированность на платформу \DotNet -- создатели \CSharp ставили своей целью предоставление разработчикам естественных средств доступа ко всем возможностям платформы .NET. Видимо, это решение можно считать более или менее вынужденным, так как платформа .NET изначально предлагала значительно большую функциональность, чем любой из существовавших на тот момент языков программирования \cite{CSharp}.

Кроме того, создатели \CSharp хотели скрыть от разработчика как можно больше незначительных технических деталей, включая операции по упаковке/распаковке типов, инициализации переменных и сборке мусора. Благодаря этому программист, пишущий на \CSharp, может лучше сконцентрироваться на содержательной части задачи. В процессе решения этой задачи проектировщики \CSharp пытались учесть уроки реализации Visual Basic'а, который достаточно успешен в скрытии деталей реализации, но недостаточно эффективен для написания крупных промышленных систем: создатели \CSharp декларируют, что новый язык обладает мощностью \CPP и в то же время простотой Visual Basic'а.


\subsubsection{Управляющие конструкции \CSharp}

Большинство современных языков программирования содержит приблизительно одинаковый набор конструкций управления и \CSharp не предлагает в этой области ничего радикально нового.

В \CSharp используются обычные присваивания для простых переменных; структурные или массовые присваивания не поддерживаются.

Операторы ветвления тоже достаточно традиционны (\lstinline{if}, \lstinline{switch}), но обладают двумя особенностями. Во-первых, условие в операторе \lstinline{if} должно вырабатывать именно булевское значение (т.е. целого значения, вырабатываемого при присваивании недостаточно), а во-вторых, каждая ветка \lstinline{case} внутри оператора \lstinline{switch} должна содержать явное указание о дальнейшем потоке управления (т.е. либо \lstinline{break}, либо \lstinline{goto} на какую-то переменную, например, на метку другой ветки).

Что касается циклов, то \CSharp поддерживает вполне традиционные циклы, такие как \lstinline{dowhile}, \lstinline{while}-\lstinline{do} и циклы с итерацией \lstinline{for}, но помимо этого, поддерживает перебор массивов и коллекций с помощью оператора \lstinline{foreach}, как в следующем примере:

\begin{lstlisting}[caption={Пример перебора коллекций}]
Hashtable ziphash = new Hashtable();

foreach (string zip in ziphash.Keys)
{
    Console.WriteLine(zip + " " + ziphash[zip]);
}
\end{lstlisting}

В этом примере надо обратить внимание на то, что перебираемый класс должен поддерживать интерфейс \lstinline{IEnumerator}, а также на тот факт, что каждый извлекаемый из коллекции объект явным образом приводится к заявленному типу перебора (в нашем примере это \lstinline{string}).

Наконец, \CSharp поддерживает структурную обработку исключений с помощью конструкций \lstinline{try}, \lstinline{catch} и \lstinline{finally}. Исключения можно генерировать и явным образом с помощью конструкции \lstinline{throw}.


\subsubsection{Типы данных и ссылочные типы}

Система типов \CSharp полностью отражает систему типов .NET и в целом достаточно типична для современных языков. Важная особенность этой системы типов заключается в явном
разделении всех типов на типы-значения и ссылочные типы.

К типам-значениям относится широкий набор примитивных типов данных, включая целые числа различной разрядности, типы с плавающей запятой различной точности, специальный тип \lstinline{decimal} с фиксированной точностью, предназначенный для финансовых вычислений, а также символьный тип \lstinline{char}, способный хранить символы в формате \lstinline{Unicode} и потому удобный при разработке интернациональных приложений. Все целочисленные типы существуют в двух вариантах: знаковом и беззнаковом.

Отметим, что \CSharp содержит также специальный тип для булевских значений; переменные булевского типа могут содержать значения true или \lstinline{false}, но в отличие от большинства современных языков программирования этим значениям не соответствует никаких численных эквивалентов.

Помимо примитивных типов, в \CSharp существует возможность организовывать данные в структуры, состоящие из переменных любого типа, или в перечисления, составленные из нескольких переменных одного и того же целочисленного типа. Важной особенностью перечислений в \CSharp является необходимость явного приведения к базовому типу при желании проинтерпретировать значение из перечисления как число.

Все ссылочные типы произведены от базового типа \lstinline{object}. Он является корнем для всей иерархии объектов в .NET и по умолчанию все классы унаследованы именно от System.Object.

Интерфейс представляет собой ссылочный тип, который может иметь только абстрактные элементы (аналогично методам, равным нулю, в \CPP). В частности, с помощью интерфейсов можно реализовать механизм множественного наследования -- для этого необходимо унаследовать класс от нескольких элементов и затем явным образом реализовать заявленную функциональность.

Делегаты (delegates) являются относительно безопасной версией указателей на функции: окружение .NET гарантирует, что представители указывают именно на допустимый объект, а не просто на некоторый адрес в памяти. Основные области применения представителей -- это методы обратного вызова и асинхронные обработчики событий.

Массивы в \CSharp бывают двух типов: многомерные (например, \lstinline{int[,,]} определяет трехмерный массив) и невыровненные (они же массивы массивов, используемые в \CPP; например, \lstinline{int[][]} определяет двухмерный массив). Несмотря на простой внешний вид, массивы являются полноценными объектами, представляющими класс System.Array.


\subsubsection{Классы}

Классы -- это основной способ организации данных в \CSharp; любая исполняемая программа, написанная на этом языке, должна представлять собой класс (так что \CSharp представляет собой <<настоящий>> объектно-ориенти\-рованный язык, в отличие, скажем, от \CPP, в котором использование объектов возможно, но необязательно).

Одним из важных принципов объектно-ориентированного подхода к программированию является инкапсуляция данных: считается, что внутреннее устройство класса и конкретная реализация его методов должны быть неизвестны внешним потребителям. Для выражения различных уровней доступности элементов программы в \CSharp существует обширный набор модификаторов, позволяющий утверждать, что на данный момент \CSharp обладает наиболее развитыми средствами поддержки инкапсуляции.

Конструкторы используются при создании конкретных экземпляров класса. Чаще всего, задачей конструктора является инициализация значений, используемых при дальнейшей работе с данным классом. Конструкторы не имеют возвращаемого значения. Если класс не содержит ни одного явного описания конструктора, то компилятор генерирует пустой конструктор, в котором выполняется единственное действие -- вызов базового класса (если таковой существует). Обычно конструкторы объявляются с модификатором \lstinline{public}, но возможно определение закрытого (\lstinline{private}) конструктора, например, в случае класса без методов (такие классы иногда специально создаются для хранения статических или глобальных переменных, так как в \CSharp любая переменная должна принадлежать какому- либо объекту).

Все активные действия программ на \CSharp выполняются в методах классов. Естественно, эти методы могут получать на вход параметры и выдавать значения. При передаче параметров в \CSharp необходимо явно указывать способ передачи -- по значению или по ссылке; в последнем случае переменной должно предшествовать ключевое слово \lstinline{ref}. Кроме того, создатели \CSharp предусмотрели возможность для возвращения более чем одного значения из метода – для этого помимо явного возвращаемого значения метода, необходимо описать один или несколько параметров метода с ключевым словом \lstinline{out}. Компилятор \CSharp проверяет, что \lstinline{ref}-параметры инициализируются перед вызовом метода, а также, что \lstinline{out}-параметры получают значение до выхода из метода. С точки зрения перегрузки методов, отличительной особенностью \CSharp является то, что методы по умолчанию не являются виртуальными. Это сделано для того, чтобы избежать ошибок, связанных со случайным переопределением унаследованных функций. Кроме того, в \CSharp есть два способа переопределения виртуального метода: при использовании ключевого слова \lstinline{override} базовый метод становится недоступным, а при использовании ключевого слова \lstinline{new} базовый метод все еще может быть вызван путем явного приведения к типу базового класса.

В объектно-ориентированном программировании считается <<хорошим тоном>> организовывать доступ к данным через специальные методы доступа get и set. Однако до недавнего времени эта рекомендация, к сожалению, совершенно не поддерживалась языками программирования. В \CSharp такая языковая возможность наконец-то появилась. Теперь обычное описание поля можно дополнить методами доступа get и set и тогда при любом чтении поля или при присваивании ему значения будет обязательно выполняться функциональность, записанная в этих методах доступа (обратите внимание, что в методе set используется ключевое слово \lstinline{value}). Методы доступа очень удобны в тех случаях, когда необходимо проверить допустимость присваиваемого значения или достаточность полномочий запрашивающего приложения для доступа к данному полю.


\subsubsection{События}

Многие современные приложения требуют применения событийно-ориентированного подхода, например, это необходимо при создании распределенной системы, обменивающейся сообщениями, или при написании программ, использующих GUI-интерфейс. В \CSharp используется модель <<публикация/подписка>> -- класс публикует те события, которые он может инициировать, а другие классы могут подписаться на получение извещений о них. Для реализации этой модели используются представители (delegates), которые выполняют в \CSharp роль <<безопасных указателей на функцию>>.


\subsubsection{Перегрузка операторов}

Перегрузка операторов -- это один из наиболее спорных механизмов в современных языках. Некоторые программисты считают, что перегрузка операторов помогает только в создании трудно находимых ошибок. Другие программисты считают механизм перегрузки операторов полезным как раз из соображений улучшения читаемости кода. Как бы то ни было, перегрузка операторов стала неотъемлемой частью \CSharp. Например, большинство классов в \CSharp по умолчанию перегружают оператор сравнения (операция == практически всегда означает вызов метода Equals, унаследованного от System.Object).

Перегрузка операторов обычно используется для того, чтобы сократить и привести к привычному виду запись операций над объектами, определенными программистом. Скажем, с объектами, представляющими математические или физические величины, обычно ассоциируются арифметические операции. Возьмем, в качестве примера квадратные матрицы -- для них естественно ввести операции сложения и умножения. Без перегрузки операторов эти действия пришлось бы записывать таким образом: A.Add(B) или Matrices.Add(A, B). И та, и другая формы записи несколько непривычны, так как традиционной формой является запись вида A + B. Попробуем реализовать ее на \CSharp:

\begin{lstlisting}[caption={Пример перегрузки операторов}]
public class Matrix
{
    ...

    public static Matrix operator + (Matrix left, Matrix right)
    {
        Matrix target = new Matrix();
        for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            target[i, j] = left[i, j] + right[i, j];
        return target;
    }
}
\end{lstlisting}

При таком описании запись сложения матриц приобретает более знакомый вид:

\begin{lstlisting}[caption={Пример использования перегруженного оператора}]
Matrix c = new Matrix();
c = a + b;
\end{lstlisting}

Таким же образом можно было бы реализовать умножение и деление матриц, сравнение и
другие операции.


\subsubsection{Прочие особенности языка \CSharp}

При написании программ очень часто возникает потребность в записи какой-то важной информации о программе или ее отдельных компонентах. Например, программисту может понадобиться определить новые свойства для создаваемых им объектов или явно указать, требуется ли наличие транзакции. При этом невозможно заранее предугадать все возможные виды информации, которые могут потребоваться, и потому язык должен предоставлять программисту возможность создания новых типов информации, привязки их к объектам программы и средства для работы с ними. Традиционным решением этой задачи была запись информации подобного рода в специальных файлах (например, .IDL или .DEF). В \CSharp для этой цели используются атрибуты, которые представляют собой <<примечания>> к элементам исходного текста программы (классам, методам, параметрам методов и т.д.). В отличие от комментариев, информация, записанная в атрибутах, не теряется во время компиляции, а сохраняется в метаданных программы и может быть извлечена с помощью механизма рефлексии.

В общем и целом, \CSharp достаточно успешно справляется с задачей скрытия излишних сложностей от программиста. Тем не менее, бывают случаи, когда программисту требуется полная свобода действий -- например, речь может идти об ускорении каких-то фрагментов исходной программы или о необходимости работы со структурами, описанными в других языках и использующих указатели.

Специально для таких ситуаций в \CSharp предусмотрена возможность написания опасного (unsafe) кода -- для этого необходимо пометить метод или блок ключевым словом \lstinline{unsafe}. Внутри опасных блоков можно применять операторы * и \&, указатели, адресную арифметику и т.д., но, естественно, сгенерированная таким образом программа не будет гарантированно безопасной.

Еще одна особенность опасного кода -- это возможность описания фиксированных (fixed) указателей. Дело в том, что прямой работе с указателями может помешать сборка мусора .NET, так как во время сборки мусора возможно перемещение всех объектов в куче. Понятно, что при перемещении объекта, с которым мы работаем через указатель, не может произойти ничего хорошего. Поэтому необходимо зафиксировать все указатели, с которыми работает опасный код; зафиксированные объекты сборщик мусора игнорирует.